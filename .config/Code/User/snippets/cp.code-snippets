{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"cp": {
		"scope": "C++,cpp,Cpp,c++",
		"prefix": "cp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long int",
			"#define endl \"\\n\"",
			"#define pll pair<ll,ll>",
			"#define vll vector<ll>",
			"#define forn(i,n) for(ll i=0; i<n; ++i)",
			"#define pb push_back",
			"#define range(c) c.begin() , c.end()",
			"#define MOD 1000000007",
			"#define Print(a) for(auto it : a)cout << (it) <<\" \";cout << endl;",
			"#define test ll t;cin >> (t);while(t--)","template <typename Arg1>",
			"void __f(const char* name, Arg1&& arg1) { cout << name << \" : \";cout << arg1 <<\" \";}",
			"template <typename Arg1, typename... Args>",
			"void __f(const char* names, Arg1&& arg1, Args&&... args) {const char *comma = strchr(names + 1, ',');cout.write(names, comma - names) << \" : \";",
			"cout << arg1 <<\" \";cout << \" | \";__f(comma + 1, args...);}",
			"char local ='O';",
			"#define db(...) if(local=='L') {__f(#__VA_ARGS__, __VA_ARGS__); cout<<endl;}",
			"//////////////////////////////////////////////////////////////",
			"int main() {",
			"ios_base::sync_with_stdio(false);",
			"cin.tie(NULL);",
			"cout.tie(NULL);",
			"#ifndef ONLINE_JUDGE",
			"\tlocal = 'L';",
			"#endif",
			"\n\t$0",
			"}"
			
		],
		"description": "CP snippet"
	} ,
	//////////////////////////////////////////////////////////////////////     MATHS    ////////////////////////////////////////////////////////////
	"binaryExponentiation": {
		"scope": "cpp,C++,Cpp,cPP, CPP",
		"prefix": "binExp",
		"body": [
		  "ll binExp(ll x,ll n)",
		  "{",
		  "    ll result=1;",
		  "    while(n>0)",
		  "    {",
		  "        if(n % 2 ==1)",
		  "            result=(result * x)%MOD;",
		  "        x=(x*x)%MOD;",
		  "        n=n/2;",
		  "    }",
		  "    return result%MOD;",
		  "}"
		],
		"description": "binaryExponentiation"
	} ,

	"modInv": {
		"scope": "cpp,C++,Cpp,cPP, CPP",
		"prefix": "modInv",
		"body": [
			"ll d,x,y;",
			"void extendedEuclid(ll A, ll B) {",
			"    if(B == 0) {",
			"        d = A;",
			"        x = 1;",
			"        y = 0;",
			"    }",
			"    else {",
			"        extendedEuclid(B, A%B);",
			"        ll temp = x;",
			"        x = y;",
			"        y = temp - (A/B)*y;",
			"    }",
			"}",
			"ll modInverse(ll A, ll M)",
			"{",
			"    extendedEuclid(A,M);",
			"    return (x%M+M)%M;",
			"}"
		],
		"description": "modInv"
	} ,
	///////////////////////////////////////////////////////////////        GRAPH     /////////////////////////////////////////////////////////////////////
	"Dijkstra's Algorithm": {
		"scope": "C++,cpp,Cpp,c++",
		"prefix": "dijkstra",
		"body": [
			"void dijkstra ()",
			"{",
				"\tmemset(vis,false,sizeof(vis));",
				"\tmemset(dis, INF, sizeof(dis));",
				"\tdis[1] = 0;",
				"\tmultiset <pair <ll,ll> > st;",
				"\tst.insert({0,1});",
				"\twhile(!st.empty())",
				"\t{",
					"\t\tauto  p = *st.begin();",
					"\t\tst.erase(st.begin());",
					"\t\tll x = p.second; ll wt = p.first;",
					"\t\tif(vis[x])",
						"\t\t\tcontinue;",
					"\t\tvis[x] = true;",
					"\t\tforn(i,adj[x].size())",
					"\t\t{",
						"\t\t\tll to = adj[x][i].first;",
						"\t\t\tll w = adj[x][i].second;",
						"\t\t\tif(dis[x] + w < dis[to])",
						"\t\t\t{",
							"\t\t\t\tdis[to] = dis[x] + w;",
							"\t\t\t\tst.insert({dis[to],to});",
						"\t\t\t}",

					"\t\t}",
				"\t}",
			"}",
		],
		"description": "Dijkstra"
	} ,

	"Articualtion Points": {
		"scope": "cpp,Cpp,c++,C++",
		"prefix": "articulation DFS",
		"body": [

		"ll parent[100005];    //def -1",
		"ll low[100005];    //def inf",
		"ll disc[100005];",
		"bool AP[100005];    //def false",
		"void dfs(ll x, ll tim)",
		"{" ,
			"\tll child = 0;",
			"\tdisc[x] = low[x] = tim+1;",
			"\tvis[x] = true;",
			"\tfor(ll u : adj[x])",
			"\t{",
				"\t\tif(!vis[u])",
				"\t\t{",
					"\t\t\tchild ++;",
					"\t\t\tparent[u] = x;",
					"\t\t\tdfs(u , tim+1);",
					"\t\t\tlow[x] = min(low[x], low[u]);",
					"\t\t\t// Root Node",
					"\t\t\tif(parent[x] == -1 && child > 1)",
						"\t\t\t\tAP[x] = true;",
					"\t\t\t//Normal Node with subtree condn.",
					"\t\t\tif(parent[x] != -1 && low[u] >= disc[x])",
					" \t\t\t\tAP[x] = true;",
				"\t\t}",
				"\t\telse if(parent[x] != u)",
					"\t\t\tlow[x] = min(low[x] , disc[u]);",
			"\t}",

		"}",
		],
		"description": "DFS Snippet for Articualation points"
	} ,

	"Segment Tree": {
		"scope": "cpp,Cpp,c++,C++",
		"prefix": "segment tree",
		"body": [
		  "ll tree[400005];",
		  "ll combine(ll lval, ll rval)",
		  "{",
		  "    return min(lval, rval);",
		  "}",
		  "void build(ll node, ll start, ll end) // node starts from 1, start and end are indices of the array",
		  "{",
		  "    if(start == end)",
		  "        tree[node] = a[start];",
		  "    else",
		  "    {",
		  "        ll mid = (start + end)/2;",
		  "        build(2*node, start, mid);",
		  "        build(2*node +1, mid+1, end);",
		  "",
		  "        tree[node] = combine( tree[2*node], tree[2*node+1]);",
		  "    }",
		  "}",
		  "void update(ll node, ll start, ll end, ll idx, ll val)",
		  "{",
		  "    // node starts from 1",
		  "    // start, end -> jurisdiction of current node in terms of indices of array",
		  "    // idx index of element to update in \"ARRAY\"",
		  "    // val to give to a[idx]",
		  "    if(start == end)",
		  "    {",
		  "        a[idx] = val;",
		  "        tree[node] = val;",
		  "    }",
		  "    else",
		  "    {",
		  "        ll mid = (start + end)/2;",
		  "        if(start <= idx && idx <= mid)",
		  "            update(2*node, start, mid, idx, val);",
		  "        else",
		  "        {",
		  "            update(2*node + 1, mid+1, end, idx, val);",
		  "        }",
		  "",
		  "        tree[node] = combine(tree[2*node], tree[2*node + 1]);",
		  "    }",
		  "}",
		  "ll query(ll node, ll start, ll end, ll l, ll r)",
		  "{",
		  "    // node starts from 1",
		  "    // start, end -> jurisdiction of current node in terms of indices of array",
		  "    // l , r -> queried indices of \"ARRAY\" incl.",
		  "",
		  "    if(r < start || end < l)",
		  "        return 1e18;",
		  "    if(l <= start && end <= r)",
		  "        return tree[node];",
		  "    ",
		  "    ll mid = (start + end)/2;",
		  "    ll p1 = query(2*node , start, mid, l, r);",
		  "    ll p2 = query(2*node + 1, mid + 1, end, l, r);",
		  "    return combine(p1,p2);",
		  "}"
		],
		"description": "Segment Tree"
	  }
}